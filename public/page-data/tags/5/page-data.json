{"componentChunkName":"component---src-templates-all-tag-post-page-tsx","path":"/tags/5/","result":{"data":{"allMdx":{"totalCount":47,"nodes":[{"frontmatter":{"thumbnail":null,"title":"16장 순환 신경망으로 순차 데이터 모델링","updatedAt":null,"createdAt":"2025/01/09","description":"데이터 간의 순서가 중요한 데이터를 시퀀스 데이터라고 한다. 시퀀스 데이터를 처리해주기 위해서는 RNN(Recurrent Neural Network) 모델을 사용해서 처리해야 한다.","slug":"ml-textbook-15","categories":["ML"],"tags":null},"excerpt":"데이터 간의 순서가 중요한 데이터를 시퀀스 데이터라고 한다. 시퀀스 데이터를 처리해주기 위해서는 RNN(Recurrent Neural Network) 모델을 사용해서 처리해야 한다…"},{"frontmatter":{"thumbnail":null,"title":"13장 텐서플로를 사용한 신경망 훈련","updatedAt":null,"createdAt":"2025/01/09","description":"복잡한 수학이나 구현 과정을 텐서플로우에서 이미 구현해 놓았다. 이를 사용하는 법을 알아보자.텐서플로우의 함수나 여러가지 기능들은 어느정도 생략하겠다. 사용하면서 익히는 것이 가장 좋다.","slug":"ml-textbook-13","categories":["ML"],"tags":null},"excerpt":"복잡한 수학이나 구현 과정을 텐서플로우에서 이미 구현해 놓았다. 이를 사용하는 법을 알아보자. 텐서플로우의 함수나 여러가지 기능들은 어느정도 생략하겠다. 사용하면서 익히는 것이…"},{"frontmatter":{"thumbnail":null,"title":"11장 레이블되지 않은 데이터 다루기: 군집 분석","updatedAt":null,"createdAt":"2025/01/09","description":"레이블이 없는 데이터들을 분석하여 비슷한 데이터들끼리 그룹으로 묶을 것이다.이를 군집으로 묶는다하여 클러스터링(clustering)이라 한다. - k-평균 알고리즘을 이용하여 클러스터 중심 찾기- 상향식 방법으로 계층적 군집 트리 만들기- 밀집도 기반의 군집 알고리즘을 사용하여 임의 모야을 가진 대상 구분하기","slug":"ml-textbook-11","categories":["ML"],"tags":null},"excerpt":"레이블이 없는 데이터들을 분석하여 비슷한 데이터들끼리 그룹으로 묶을 것이다. 이를 군집으로 묶는다하여 클러스터링(clustering)이라 한다.\n\nk-평균 알고리즘을 이용하여…"},{"frontmatter":{"thumbnail":null,"title":"머신러닝 교과서 10장","updatedAt":null,"createdAt":"2025/01/09","description":"선형 회귀 모델에 대해 알아보자. 보스턴 집 가격 예측 문제를 예시로 들어서 설명하겠다.","slug":"ml-textbook-10","categories":["ML"],"tags":["Linear-Regression"]},"excerpt":"선형 회귀 모델에 대해 알아보자. 보스턴 집 가격 예측 문제를 예시로 들어서 설명하겠다.\n\n데이터 셋을 상관관계나 산점도를 그려 분석한다.\n\n사이킷런의…"},{"frontmatter":{"thumbnail":null,"title":"12장 다층 인공 신경망을 밑바닥부터 구현","updatedAt":null,"createdAt":"2025/01/09","description":"딥러닝은 인공 신경망을 효과적으로 학습시키기 위한 머신러닝의 하위분야이다. 아래 내용을 소개하겠다.- 다층 신경망 개념- 역전파 알고리즘- 이미지 분류를 위한 다층 신경망 훈련","slug":"ml-textbook-12","categories":["ML"],"tags":null},"excerpt":"딥러닝은 인공 신경망을 효과적으로 학습시키기 위한 머신러닝의 하위분야이다. 아래 내용을 소개하겠다. 다층 신경망 개념 역전파 알고리즘 이미지 분류를 위한 다층 신경망 훈련\n\n인…"},{"frontmatter":{"thumbnail":null,"title":"가중치 w와 L2 규제","updatedAt":null,"createdAt":"2025/01/06","description":"왜 norm을 사용하는 것이 과대적합을 해결할까? 그 이유를 살펴보자.","slug":"ml-textbook-2","categories":["ML"],"tags":["규제","과대적합"]},"excerpt":"모델이 과대적합이 되었을 때 우리는 norm을 통해 이를 해결한다. 그런데 왜 norm을 사용하는 것이 과대적합을 해결할까? 그 이유를 살펴보자.\n\n모델이 과도하게 훈련 데이터에만…"},{"frontmatter":{"thumbnail":null,"title":"머신러닝 분류 모델들","updatedAt":null,"createdAt":"2025/01/06","description":"머신러닝에 사용하는 다양한 분류 모델들에 대해서 얘기해 보겠다.","slug":"ml-textbook-3","categories":["ML"],"tags":["SVM","커널-SVM","결정-트리","랜덤-포레스트"]},"excerpt":"머신러닝에 사용하는 다양한 분류 모델들에 대해서 얘기해 보겠다. SVM(Support Vector Machine)이라 불리는 이 분류 모델은 클래스를 구분하는 hyper…"},{"frontmatter":{"thumbnail":null,"title":"백준 17407 - 괄호 문자열과 쿼리","updatedAt":null,"createdAt":"2025/01/01","description":"백준 17407 - 괄호 문자열과 쿼리","slug":"boj-17407","categories":["PS"],"tags":["lazy-segment","누적합"]},"excerpt":"풀이# (을 +1, )을 -1로 한 다음 누적합을 먼저 계산한다.\n 이 누적합에 대한 lazy segment tree를 만든다.\n\n만약 x번째 문자를 (에서 )으로 바꾼다면 x…"},{"frontmatter":{"thumbnail":null,"title":"백준 1462 - 퀴즈쇼","updatedAt":null,"createdAt":"2024/12/26","description":"백준 1462 - 퀴즈쇼","slug":"boj-1462","categories":["PS"],"tags":["누적합","다이나믹-프로그래밍"]},"excerpt":"풀이# dp[i][0] := 1~i 까지 문제를 푸는데, i를 풀고 나서 남은 코인의 갯수가 0개일 때의 최댓값\n dp[i][1] := 1~i 가지 문제를 푸는데, i를 풀고 나서…"}],"pageInfo":{"currentPage":5,"pageCount":6}},"ogimage":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/f689f8b3b021090c7d4495f61be56e2f/ee21c/og-image.png","srcSet":"/static/f689f8b3b021090c7d4495f61be56e2f/5fe58/og-image.png 256w,\n/static/f689f8b3b021090c7d4495f61be56e2f/5ca6c/og-image.png 512w,\n/static/f689f8b3b021090c7d4495f61be56e2f/ee21c/og-image.png 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"},"sources":[{"srcSet":"/static/f689f8b3b021090c7d4495f61be56e2f/e818d/og-image.webp 256w,\n/static/f689f8b3b021090c7d4495f61be56e2f/7948c/og-image.webp 512w,\n/static/f689f8b3b021090c7d4495f61be56e2f/aa8b2/og-image.webp 1024w","type":"image/webp","sizes":"(min-width: 1024px) 1024px, 100vw"}]},"width":1024,"height":600}},"profileImage":null,"shortPosts":{"nodes":[{"frontmatter":{"title":"Word2Vec과 GloVe의 차이는 무엇일까?","updatedAt":null,"createdAt":"2025/04/27","slug":"diff-between-word2vec-and-glove","tags":null}},{"frontmatter":{"title":"Cross Entropy와 Softmax","updatedAt":null,"createdAt":"2025/04/27","slug":"cross-entropy-and-softmax","tags":null}},{"frontmatter":{"title":"Batch Normalization을 하는 이유는 뭘까?","updatedAt":null,"createdAt":"2025/04/25","slug":"why-do-batch-normalization","tags":null}},{"frontmatter":{"title":"삼격형의 두 변의 길이와 사잇각을 알 때, 나머지 한 변의 길이를 구하는 공식","updatedAt":null,"createdAt":"2025/02/20","slug":"formula-for-the-third-side-of-a-triangle-given-two-sides-and-the-included-angle","tags":["수학-공식"]}},{"frontmatter":{"title":"c++에서 내림차순에 대한 lower_bound와 upper_bound하기","updatedAt":null,"createdAt":"2025/02/10","slug":"descending-order-binary-search","tags":[]}},{"frontmatter":{"title":"세 점의 좌표가 주어졌을 때 삼각형의 면적 구하는 방법","updatedAt":null,"createdAt":"2025/01/13","slug":"how-to-calculate-triangle-area","tags":["수학-공식"]}},{"frontmatter":{"title":"C++에서 이진수의 비트 수를 세는 방법","updatedAt":null,"createdAt":"2025/01/13","slug":"count-bit-in-cpp","tags":[]}},{"frontmatter":{"title":"표준화와 정규화","updatedAt":null,"createdAt":"2025/01/09","slug":"ml-textbook-4","tags":["표준화","정규화"]}},{"frontmatter":{"title":"로지스틱 회귀의 비용 함수는 왜 이렇게 생겼을까?","updatedAt":null,"createdAt":"2024/12/26","slug":"ml-textbook-1","tags":["로지스틱","회귀","손실함수"]}}]},"featuredPosts":{"nodes":[{"frontmatter":{"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/076eddc91e0d4685f11210bb0b088b7d/06a5c/cover.png","srcSet":"/static/076eddc91e0d4685f11210bb0b088b7d/2ed3a/cover.png 142w,\n/static/076eddc91e0d4685f11210bb0b088b7d/f4be8/cover.png 284w,\n/static/076eddc91e0d4685f11210bb0b088b7d/06a5c/cover.png 568w","sizes":"(min-width: 568px) 568px, 100vw"},"sources":[{"srcSet":"/static/076eddc91e0d4685f11210bb0b088b7d/bcdd4/cover.webp 142w,\n/static/076eddc91e0d4685f11210bb0b088b7d/5d551/cover.webp 284w,\n/static/076eddc91e0d4685f11210bb0b088b7d/47346/cover.webp 568w","type":"image/webp","sizes":"(min-width: 568px) 568px, 100vw"}]},"width":568,"height":568}}},"title":"RNN","updatedAt":null,"createdAt":"2025/04/27","description":null,"slug":"intro-to-nlp-7","categories":["ML"],"tags":null},"excerpt":"언어 모델이라는 건, 사실 다음에 올 단어를 확률로 예측하는 것이다. 이러한 언어 모델들을 어떻게 발전시켜왔는 지 살펴보자.\n\n이미 이전 포스트에서 자세히 살펴보았던 내용이다.…"},{"frontmatter":{"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/85dad8627ae6845b62f5bb965c291b19/808a1/cover.png","srcSet":"/static/85dad8627ae6845b62f5bb965c291b19/74f11/cover.png 294w,\n/static/85dad8627ae6845b62f5bb965c291b19/bbc95/cover.png 588w,\n/static/85dad8627ae6845b62f5bb965c291b19/808a1/cover.png 1176w","sizes":"(min-width: 1176px) 1176px, 100vw"},"sources":[{"srcSet":"/static/85dad8627ae6845b62f5bb965c291b19/c143a/cover.webp 294w,\n/static/85dad8627ae6845b62f5bb965c291b19/e86a6/cover.webp 588w,\n/static/85dad8627ae6845b62f5bb965c291b19/8199d/cover.webp 1176w","type":"image/webp","sizes":"(min-width: 1176px) 1176px, 100vw"}]},"width":1176,"height":522}}},"title":"Word2Vec","updatedAt":null,"createdAt":"2025/04/26","description":null,"slug":"intro-to-nlp-4","categories":["ML"],"tags":null},"excerpt":"저번에 word vector에 대해서 알아봤는데, 이번에는 word vector의 프레임워크인 Word2Vec에 대해서 좀 더 알아보자. 먼저 Word2Vec이 어떤 식으로…"},{"frontmatter":{"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3984361aed6a71f465c0ae457e7eff24/558a4/cover.png","srcSet":"/static/3984361aed6a71f465c0ae457e7eff24/0701a/cover.png 164w,\n/static/3984361aed6a71f465c0ae457e7eff24/4c324/cover.png 328w,\n/static/3984361aed6a71f465c0ae457e7eff24/558a4/cover.png 656w","sizes":"(min-width: 656px) 656px, 100vw"},"sources":[{"srcSet":"/static/3984361aed6a71f465c0ae457e7eff24/5da8b/cover.webp 164w,\n/static/3984361aed6a71f465c0ae457e7eff24/fab23/cover.webp 328w,\n/static/3984361aed6a71f465c0ae457e7eff24/31f9d/cover.webp 656w","type":"image/webp","sizes":"(min-width: 656px) 656px, 100vw"}]},"width":656,"height":381}}},"title":"Word Vectors","updatedAt":null,"createdAt":"2025/04/25","description":null,"slug":"intro-to-nlp-3","categories":["ML"],"tags":null},"excerpt":"이번 포스트에서는 Word Vector에 대해서 알아보자. 먼저 아래와 같은 고민을 해보자.\n 우리는 어떻게 컴퓨터에게 단어의 뜻을 이해시킬 수 있을까?\n\nWordNet?#\n\n예전에…"},{"frontmatter":{"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/f566903779599cee1d9c25328b1d3436/a5e5c/cover.png","srcSet":"/static/f566903779599cee1d9c25328b1d3436/13d64/cover.png 627w,\n/static/f566903779599cee1d9c25328b1d3436/5404f/cover.png 1253w,\n/static/f566903779599cee1d9c25328b1d3436/a5e5c/cover.png 2506w","sizes":"(min-width: 2506px) 2506px, 100vw"},"sources":[{"srcSet":"/static/f566903779599cee1d9c25328b1d3436/9ac18/cover.webp 627w,\n/static/f566903779599cee1d9c25328b1d3436/06a54/cover.webp 1253w,\n/static/f566903779599cee1d9c25328b1d3436/21a7f/cover.webp 2506w","type":"image/webp","sizes":"(min-width: 2506px) 2506px, 100vw"}]},"width":2506,"height":1368}}},"title":"Quantized Side Tuning 논문 리뷰","updatedAt":null,"createdAt":"2025/03/11","description":"Quantized Side Tuning: Fast and Memory-Efficient Tuning ofQuantized Large Language Models 논문에 대한 리뷰를 작성한 글입니다.","slug":"Quantized Side Tuning","categories":["paper"],"tags":null},"excerpt":"위 포스트는 Quantized Side Tuning: Fast and Memory-Efficient Tuning ofQuantized Large Language Models 논문에…"}]}},"pageContext":{"limit":9,"skip":36,"numPages":6,"currentPage":5}},"staticQueryHashes":["3461282698","445630073"],"slicesMap":{}}