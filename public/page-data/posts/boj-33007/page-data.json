{"componentChunkName":"component---src-templates-post-page-tsx-content-file-path-users-jinsoo-git-jinsoolve-blog-content-ps-boj-33007-untitled-mdx","path":"/posts/boj-33007/","result":{"data":{"post":{"frontmatter":{"slug":"boj-33007","title":"백준 33007 - Greatest of the Greatest Common Divisors","locale":null,"description":null,"categories":["PS"],"tags":["수학","정수론","세그먼트-트리","오프라인-쿼리"],"createdAt":"2025/01/11","updatedAt":null,"thumbnail":null},"myTableOfContents":{"items":[{"depth":1,"title":"백준 33007 - Greatest of the Greatest Common Divisors","url":"#my-heading-1","items":[{"depth":2,"title":"핵심 아이디어","url":"#my-heading-2","items":[]},{"depth":2,"title":"풀이","url":"#my-heading-3","items":[]},{"depth":2,"title":"코드","url":"#my-heading-4","items":[]}]},{"depth":1,"title":"참고","url":"#my-heading-5","items":[]}]}},"otherLocalePost":{"nodes":[{"frontmatter":{"locale":null}}]},"relatedPosts":{"nodes":[{"frontmatter":{"slug":"boj-28129","title":"백준 28129 - 2022 APC가 어려웠다고요?","description":null,"categories":["PS"],"tags":["다이나믹-프로그래밍","누적합"],"createdAt":"2025/03/28","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 28129 - 2022 APC가 어려웠다고요?의 풀이입니다. dp[i][j] := i번째 수가 j가 되는 경우의 수\n\ndp[i][j]=∑k=max(j−k,a[i−…"},{"frontmatter":{"slug":"boj-1787","title":"백준 1787 - 문자열의 주기 예측","description":null,"categories":["PS"],"tags":["다이나믹-프로그래밍","문자열","KMP"],"createdAt":"2025/03/05","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 1787 - 문자열의 주기 예측 의 해설입니다. 결국 부분 문자열에서 가장 짧으면서 일치하는 Prefix와 Suffix를 찾으면 된다. (해당 길이를 전체…"},{"frontmatter":{"slug":"boj-1055","title":"백준 1055 - 끝이없음","description":null,"categories":["PS"],"tags":["구현","재귀"],"createdAt":"2025/03/05","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 1055 - 끝이없음의 해설입니다. 문자열이 재귀적으로 반복하는 것을 알 수 있다.\n\n이때 min과 max의 차이가 최대 100개 정도임을 알 수 있고, 우리는…"},{"frontmatter":{"slug":"boj-8872","title":"백준 8872 - 빌라봉","description":null,"categories":["PS"],"tags":["트리","그래프-탐색","그래프-이론","깊이-우선-탐색"],"createdAt":"2025/03/04","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 8872 - 빌라봉 문제의 해설입니다. 위 문제에는 여러 개의 트리가 존재한다.\n 임의의 2개의 트리를 서로 이을 때 최대 시간이 최소가 되게 하기 위해서는 각…"},{"frontmatter":{"slug":"boj-6569","title":"백준 6569 - 몬드리안의 꿈","description":null,"categories":["PS"],"tags":["다이나믹-프로그래밍","비트마스킹"],"createdAt":"2025/02/28","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 6569 - 몬드리안의 꿈에 대한 해설입니다. ...\t ...\t ...\t ...\t ...\t ...\t ...\t ... 채워짐\t 채워짐\t 채워짐\t 채워짐\t 채워짐\t 채워짐…"},{"frontmatter":{"slug":"boj-24979","title":"백준 24979 - COW Operations","description":null,"categories":["PS"],"tags":["문자열","누적합","애드-혹"],"createdAt":"2025/02/28","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 24979 - COW Operations에 대한 해설입니다. 아이디어1#\n\n주어진 Operation을 해보면 아래와 같은 변환이 가능하다는 것을 알 수 있다.…"},{"frontmatter":{"slug":"boj-1646","title":"백준 1646 - 피이보나치 트리","description":null,"categories":["PS"],"tags":["다이나믹-프로그래밍","트리","재귀"],"createdAt":"2025/02/26","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 1646 - 피이보나치 트리 문제에 대한 해설입니다. 관찰1#\n\nn번 피이보나치 트리의 루트의 왼쪽 서브트리는 n-2번 째 피이보나치 트리이고, 오른쪽 서브트리는…"},{"frontmatter":{"slug":"boj-1155","title":"백준 1155 - 변형 하노이","description":null,"categories":["PS"],"tags":["다이나믹-프로그래밍","애드-혹"],"createdAt":"2025/02/19","updatedAt":null,"thumbnail":null},"excerpt":"위 포스트는 백준 1155 - 변형 하노이 문제의 해설입니다. 아이디어 1#\n\nA번 폴: n번 디스크\n B번 폴: 1 ~ n-1 번 디스크\n C번 폴: 빔\n\n위 경우 n번 디스크는…"},{"frontmatter":{"slug":"boj-25315","title":"백준 25315 - N수매화검법","description":null,"categories":["PS"],"tags":["기하학","그리디","선분-교차-판정"],"createdAt":"2025/02/18","updatedAt":null,"thumbnail":null},"excerpt":"백준 25315번 - N수매화검법 문제의 해설입니다. 서로 교차하는 베기 A와 베기 B가 있을 때, 두 베기가 사라지려면 딱 2가지 경우이다.\n WA×(m+1)+WB×(m)W_{A…"},{"frontmatter":{"slug":"boj-24491","title":"백준 24491 - Searching for Soulmates","description":null,"categories":["PS"],"tags":["애드-혹","비트마스킹"],"createdAt":"2025/01/13","updatedAt":null,"thumbnail":null},"excerpt":"각 테스트케이스마다 2개의 1 ~ 101810^{18}1018의 수 a, b가 주어질 때, a를 b로 만드는데 드는 최소의 연산 횟수를 구하는 문제이다. 이때 연산은 ×2\\tim…"},{"frontmatter":{"slug":"boj-10321","title":"백준 10321 - 요새 건설","description":"","categories":["PS"],"tags":["기하학","convex-hull"],"createdAt":"2025/01/13","updatedAt":null,"thumbnail":null},"excerpt":"핵심 아이디어# 껍질에 있는 점들을 대상으로 임의의 대각선에 대해서 해당 대각선에서 가장 먼 점 2개를 고르면 해당 대각선으로 만들 수 있는 가장 큰 영역이다. 이때 먼점 2개는…"},{"frontmatter":{"slug":"boj-17407","title":"백준 17407 - 괄호 문자열과 쿼리","description":"백준 17407 - 괄호 문자열과 쿼리","categories":["PS"],"tags":["lazy-segment","누적합"],"createdAt":"2025/01/01","updatedAt":null,"thumbnail":null},"excerpt":"풀이# (을 +1, )을 -1로 한 다음 누적합을 먼저 계산한다.\n 이 누적합에 대한 lazy segment tree를 만든다.\n\n만약 x번째 문자를 (에서 )으로 바꾼다면 x…"},{"frontmatter":{"slug":"boj-1462","title":"백준 1462 - 퀴즈쇼","description":"백준 1462 - 퀴즈쇼","categories":["PS"],"tags":["누적합","다이나믹-프로그래밍"],"createdAt":"2024/12/26","updatedAt":null,"thumbnail":null},"excerpt":"풀이# dp[i][0] := 1~i 까지 문제를 푸는데, i를 풀고 나서 남은 코인의 갯수가 0개일 때의 최댓값\n dp[i][1] := 1~i 가지 문제를 푸는데, i를 풀고 나서…"}]}},"pageContext":{"categories":["PS"],"tags":["수학","정수론","세그먼트-트리","오프라인-쿼리"],"slug":"boj-33007","id":"d4039bd4-e02d-5495-ba1c-7b811649559f","myTableOfContents":{"items":[{"depth":1,"title":"백준 33007 - Greatest of the Greatest Common Divisors","url":"#my-heading-1","items":[{"depth":2,"title":"핵심 아이디어","url":"#my-heading-2","items":[]},{"depth":2,"title":"풀이","url":"#my-heading-3","items":[]},{"depth":2,"title":"코드","url":"#my-heading-4","items":[]}]},{"depth":1,"title":"참고","url":"#my-heading-5","items":[]}]},"readingTime":{"text":"3 min read","minutes":2.318,"time":139080,"words":1159},"frontmatter":{"slug":"boj-33007","title":"백준 33007 - Greatest of the Greatest Common Divisors","description":null,"thumbnail":null,"categories":["PS"],"tags":["수학","정수론","세그먼트-트리","오프라인-쿼리"],"createdAt":"2025/01/11","updatedAt":null,"featured":false}}},"staticQueryHashes":["3461282698"],"slicesMap":{}}