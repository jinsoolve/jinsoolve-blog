---
title: 'HTTP가 무엇인가'
description: '읽고 쓰고 맛보고 즐기고'
coverImage: '/assets/blog/computer-science/What-is-http/cover.png'
category: '컴퓨터 과학'
date: '2022/04/26'
path: 'computer-science'
---

> 해당 글은 [그림으로 배우는 HTTP & Network basic](http://www.yes24.com/Product/Goods/15894097)을 읽고 정리한 글입니다.

# 웹은 HTTP로 나타낸다.

웹 브라우저 주소란에 URL을 입력했을 떄 어떻게 웹 페이지가 보여질까요?
웹 브라우저는 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일등의 정보를 얻고 있는 것 입니다.

이 때, 서버에 의뢰를 하는 웹 브라우저는 클라이언트, 요청을 보내는 곳은 웹 서버라고 합니다.

![브라우저와 서버](/assets/blog/computer-science/What-is-http/1.png)_브라우저와 서버_

이렇게 클라이언트와 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 HTTP(Hyper Text Transfer Protocol)이라고 불리는 프로토콜입니다.

프로토콜은 일종의 **약속**입니다.

# 네트워크의 기본은 TCP/IP

> 이 포스팅에서는 주로 HTTP를 다루므로, TCP/IP는 간략하게 넘어가겠습니다. 더욱 알고 싶으시면 다른 자료를 더 찾아보시는 것을 추천드립니다.

HTTP를 이해하기 위해서는 TCP/IP 프로토콜에 대해 어느 정도 알고 있어야 합니다.
인터넷을 포함해서 일반적으로 사용하고 있는 네트워크는 TCP/IP라는 프로토콜에서 움직이고 있습니다. HTTP는 그 중 하나입니다.

프로토콜은 서로 통신하기 위한 약속입니다. 그 중에서 인터넷과 관련해서 케이블 규격, IP 주소 지정 방법, 떨어진 상대를 찾기 위한 방법과 그 곳에 도달하는 순서, 웹을 표시하기 위한 순서 등등 인터넷과 관련된 프로토콜을 모아둔 것을 `TCP/IP ` 프로토콜이라고 합니다.

`TCP/IP`는 계층화(layer)로 되어있는데, 애플리케이션, 트랜스포트, 네트워크, 링크 계층 이렇게 4개의 계층으로 되어있습니다.

계층화에는 여러 장점이 있는데, 그 중 하나는 각각의 계층이 변경이 되어도 다른 계층은 신경쓰지 않아도 된다는 분리의 이점이 있습니다. 그래서 각 계층은 다른 계층에 영향받지 않고 자유롭게 설계할 수 있습니다.

## 애플리케이션 계층

애플리케이션에서 사용하는 통신의 움직임을 결정하는 곳 입니다.
`FTP` (파일 전송 프로토콜), `DNS` (도메인 네임 스페이스) 등이 애플리케이션의 한 가지 입니다. `HTTP`도 이 계층에 포함됩니다.

## 트랜스포트 계층

트랜스포트 계층은 애플리케이션 계층에서 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 **데이터 흐름**을 제공합니다. 트랜스포트 계층에서는 서로 다른 성질을 가진 `TCP(Transmission Control Protocol)`와 `UDP(User Data Protocol)`로 두 가지 프로토콜이 있습니다.

## 네트워크 계층(혹은 인터넷 계층)

네트워크 계층은 네트워크 상에서 패킷의 이동을 다룹니다. 패킷이란 전송하는 데이터의 최소 단위입니다. 이 계층에서는 어떠한 경로를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 합니다.

인터넷의 경우라면 상대 컴퓨터에 도달하는 동안에 경로를 지정할 떄 하나의 길을 결정하는 것이 네트워크 계층의 역할입니다.

## 링크 계층 (혹은 데이터 링크 계층, 네트워크 인터페이스 계층)

네트워크에 접속하는 하드웨어적인 면만 다룹니다. 운영체제가 하드웨어를 제어하기 떄문에 디바이스 드라이버랑 네트워크 인터페이스 카드를 포함합니다.

그리고 케이블 등과 같이 물리적으로 보이는 부분(커텍트 등을 포함한 여러 가지 전송 매체)도 포함합니다. 하드웨어, 물리적인 부분은 전부 링크 계층의 역할입니다.

![TCP/IP 통신의 흐름](/assets/blog/computer-science/What-is-http/2.png)_TCP/IP 통신의 흐름_

# HTTP와 관계가 깊은 프로토콜은 IP, TCP, DNS

## 패킷을 전달하기 위한 IP

요기서 IP는 Internet Protocol입니다. 우리가 흔히 말하는 IP 주소와는 다릅니다. IP의 역할은 개개의 패킷을 상대방에게 전달하는 것입니다. IP는 `ARP(Address Resolution Protocol)`을 통해서 MAC 주소를 사용해서 목적지까지 찾아갑니다.

## 신뢰성을 담당하는 TCP

`TCP`는 계층으로 말하면 트랜스포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공합니다.

**스트림 서비스**는 용량이 큰 데이터를 보내기 쉽게 `TCP 세그먼트`라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말합니다.

**신뢰성 있는 서비스**는 `Three way handshaking`이라는 방법을 이용해서 패킷을 보내고 나서 상대방에게 잘 보내졌는지 확인하는 방법을 이용해서 통신의 신뢰성을 보증합니다.

그러니까 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하고, 정확하게 도착했는지 확인하는 역할을 하고 있습니다.

## 이름 해결을 담당하는 DNS

[DNS](https://junghyeonsu-dev.vercel.app/posts/What-is-DNS)는 HTTP와 같이 응용(애플리케이션) 계층에서 도메인 이름과 IP 주소 이름 확인을 제공합니다.

# 다시 HTTP

> 해당 장은 대부분 HTTP 1.1 버전을 기준으로 설명합니다.

아래에서 HTTP의 기본적인 내용들에 대해서 살펴보겠습니다.

## 1. HTTP는 클라이언트와 서버 간에 통신을 한다.

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 합니다. 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 됩니다.

## 2. Request(요청)과 Response(응답)을 교환해서 성립한다.

반드시 클라이언트에서 요청을 보내고, 결과가 서버에서 응답으로 되돌아옵니다. 반드시 클라이언트 측으로부터 통신이 시작됩니다.

## 3. HTTP는 상태를 유지하지 않는 프로토콜이다.

HTTP는 상태를 유지하지 않는 스테이트리스(stateless) 프로토콜입니다. 응답과 요청을 주고 받는 동안에 상태를 관리하지 않습니다.

> 클라이언트: 전에 뭘 보냈었지?
> 서버: 전에 뭘 보냈었지?

그래서 HTTP에서 요청을 보낼 때 마다 새로운 응답이 생성됩니다. 과거의 데이터를 전혀 가지고 있지 않습니다. HTTP는 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)를 확보하기 위해서 이와 같이 간단하게 설계되어 있습니다.

근데 웹이 진화함에 따라서, `stateless` 특성으로는 처리하기 어려운 일이 많아졌습니다.
로그인 정보를 유지를 해야하는 경우가 많은데, HTTP 프로토콜은 상태를 유지하지 않기 때문에, 이 대신에 쿠키라는 기술이 도입이 되어 통신에서도 계속 상태를 관리할 수 있게 되었습니다.

## 4. 요청 URI로 리소스를 식별한다.

> URI과 URL은 다른 의미이지만 요기에서는 동일하게 생각해도 무관합니다.

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정합니다. 이 URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있습니다.

- http://www.helloworld.com/index.html
- http://www.hackr.jp/
- http://www.catanddog.com/photo/dog1.jpeg

위와 같이 HTTP는 URI라고 불리는 형식으로 모든 요청에 URI를 포함해야 합니다.

## 5. 서버에 임무를 부여하는 HTTP 메소드들

> 해당 메소드들은 HTTP 1.1 버전에서 사용할 수 있습니다.

- `GET`: 리소스 획득
- `POST`: 엔티티 전송
- `PUT`: 파일 전송
- `HEAD`: 메세지 헤더 획득
- `DELETE`: 파일 삭제
- `OPTIONS`: 제공하고 있는 메소드의 문의
- `TRACE`: 경로 조사
- `CONNECT`: 프록시에 터널링 요구

## 6. 지속 연결과 파이프라인화로 접속량을 절약

HTTP 초기 버전에는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었습니다. 초기에는 작은 사이즈의 텍스트를 보내는 정도여서 상관없었지만, 웹이 발전함에 따라 다량의 이미지, 텍스트, 컨텐츠를 보내고 있기 때문에 한 번 요청을 보낼 때 TCP 연결을 하고, 종료하고 하는 작업이 엄청난 통신량으로 다가왔습니다.

그래서 HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 지속 연결이라는 방법을 고안했습니다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않으면 TCP 연결을 계속 유지하는 방식입니다.

지속 연결이 가능해짐에 따라 클라이언트와 서버의 파이프라인화가 가능해졌습니다.
파이프라인화에 의해서 이전에는 요청 이후에 응답이 올 떄까지 기다린 뒤에 다시 요청을 보내던 것을 응답을 기다리지 않고 요청을 계속해서 보낼 수 있습니다.

> HTTP/0.9, 일부 HTTP/1.0(개별 연결) < 일부 HTTP/1.0, HTTP/1.1 (지속 연결) < HTTP/1.1 파이프라인화

개별 연결보다는 지속 연결이 요청 완료가 빠르고, 지속 연결보다는 파이프라인화 쪽이 빠릅니다. 이 차이는 요청 수가 늘어날 수록 현저하게 차이가 납니다.

![파이프라인화](/assets/blog/computer-science/What-is-http/3.png)_파이프라인화_

## 7. 쿠키를 사용한 상태 관리

HTTP는 스테이트리스(stateless) 프로토콜 이므로, 요청과 응답의 상태를 관리하지 않습니다. 그래서 과거의 상태를 근거로 무언가를 처리하는 것은 불가능합니다.

예를 들어 인증이 필요한 웹 사이트에서 상태 관리를 하지 않는다면, 인증을 마친 상태를 기억하지 못하기 때문에 새로운 페이지로 이동할 때마다 인증을 다시 한다거나, 요청에 매개 변수나 추가적인 정보를 붙여서 지속적으로 로그인 상태를 확인해야 하는 상황이 발생합니다.

스테이트리스가 위 처럼 단점만 있는 건 아닙니다. 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있습니다. 그리고 단순하게 설계되었기 때문에 좀 더 다양한 곳에서 사용할 수 있다는 장점이 있습니다.

하지만 스테이트리스의 단점을 보완하기 위해서 쿠키(cookie) 시스템이 도입되었습니다. 쿠키는 서버에서 응답으로 보내진 `Set-Cookie`라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 요청을 보내면 자동적으로 쿠키를 싣어서 송신합니다. 이렇게 서버는 클라이언트가 자동적으로 같이 보낸 쿠키를 통해서 상태를 관리하고 체크해서 그에 맞는 응답을 보내줄 수 있습니다.
